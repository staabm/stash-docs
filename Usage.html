

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Usage &mdash; Stash 0.9.5 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Stash 0.9.5 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="Contents.html">Stash 0.9.5 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h1>
<div class="section" id="autoloading">
<h2>Autoloading<a class="headerlink" href="#autoloading" title="Permalink to this headline">¶</a></h2>
<p>The Stash library conforms to the PSR-0 autoloading standard. If your project doesn&#8217;t already use a PSR-0 compliant autoloader, you can simply include the <cite>autoload.php</cite> file at the root of the project to load Stash classes.</p>
<p>All of Stash&#8217;s classes live in the Stash namespace.</p>
</div>
<div class="section" id="creating-stash-objects">
<h2>Creating Stash Objects<a class="headerlink" href="#creating-stash-objects" title="Permalink to this headline">¶</a></h2>
<p>Creating a basic Stash object is simple:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Cache</span><span class="p">();</span>

<span class="c1">// Set the &quot;key&quot;, which is the path the Stash object points to.</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">setupKey</span><span class="p">(</span><span class="s1">&#39;path/to/data&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This will create a cache object with no cross request storage, meaning the data will only be cached for the lifetime of that one script or request. In order to store cache results across requests, we need a handler. Each handler interfaces with a specific form of persistent storage.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// Create Handler with default options</span>
<span class="nv">$stashFileSystem</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Handler\FileSystem</span><span class="p">();</span>

<span class="c1">// Create the actual cache object, injecting the backend</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Cache</span><span class="p">(</span><span class="nv">$stashFileSystem</span><span class="p">);</span>

<span class="c1">// Set the &quot;key&quot;, which is the path the Stash object points to. This will be discussed in depth later,</span>
<span class="c1">// but for now just know it&#39;s an identifier.</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">setupKey</span><span class="p">(</span><span class="s1">&#39;path/to/data&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Each handler object can be used by many different cache objects, so that any initial setup and overhead (database connections, file handlers, etc.) can be done only once per request. In order to simplify this process, the Pool class automates the process of handler creation to ensure that all cache objects use the same handlers.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// Create Handler with default options</span>
<span class="nv">$stashFileSystem</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Handler\FileSystem</span><span class="p">();</span>

<span class="c1">// Create pool and inject handler</span>
<span class="nv">$pool</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Pool</span><span class="p">();</span>
<span class="nv">$pool</span><span class="o">-&gt;</span><span class="na">setHandler</span><span class="p">(</span><span class="nv">$stashFileSystem</span><span class="p">);</span>

<span class="c1">// Retrieve a single cache item</span>
<span class="nv">$pool</span><span class="o">-&gt;</span><span class="na">getCache</span><span class="p">(</span><span class="s1">&#39;path/to/data&#39;</span><span class="p">);</span>

<span class="c1">// Retrieve an iterator containing multiple cache items</span>
<span class="nv">$pool</span><span class="o">-&gt;</span><span class="na">getCacheIterator</span><span class="p">(</span><span class="s1">&#39;path/to/data&#39;</span><span class="p">,</span> <span class="s1">&#39;path/to/more/data&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="identifying-stored-data-using-keys">
<h2>Identifying Stored Data Using Keys<a class="headerlink" href="#identifying-stored-data-using-keys" title="Permalink to this headline">¶</a></h2>
<p>Stash identifies items in the cache pool using keys. Keys are simple: a set of strings, delimited by the &#8216;/&#8217; character.</p>
<p>The best way to think about keys is to think of them like a filesystem. Filesystems have different folders that contain more folders and files. Folders can be nested to virtually unlimited levels, allowing files to be organized according to various criteria. Stash uses the same principal- different nodes can contain both data and more nodes, allowing developers to group data together just like they would files. This makes clearing groups of items in the cache as simple as clearing their parent node, just like deleting a directory would erase all the files underneath.</p>
<p>A project that had different models, each identified by an id and a type, might have it&#8217;s keys for those models start with models/type/id, with individual pieces of data stored in keys inside of those. If the user &#8220;bob&#8221; had the id &#8220;32&#8221;, the path to his data in the cache would be &#8220;models/users/32&#8221;.</p>
<p>Stash methods that accept keys can accept them in two forms: as a slash-delimited string, or as a series of arguments.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// Pass the key as a string</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="nv">$pool</span><span class="o">-&gt;</span><span class="na">getCache</span><span class="p">(</span><span class="s1">&#39;models/users/32/info&#39;</span><span class="p">);</span>

<span class="c1">// Pass the key as a series of arguments</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="nv">$pool</span><span class="o">-&gt;</span><span class="na">getCache</span><span class="p">(</span><span class="s1">&#39;models&#39;</span><span class="p">,</span> <span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="nv">$id</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="storing-and-retrieving-data">
<h2>Storing and Retrieving Data<a class="headerlink" href="#storing-and-retrieving-data" title="Permalink to this headline">¶</a></h2>
<p>Storing data in Stash (and retrieving it in future requests) is easy. Three functions do the bulk of the work:</p>
<ul class="simple">
<li><em>get()</em> - Returns data that was previously stored, or null if nothing stored. (Since it is possible to store null values it is very important not to rely on a null return to check for a cache miss.)</li>
<li><em>isMiss()</em> - Returns true if no data is stored or the data is stale; returns false if fresh data is present.</li>
<li><em>store($data, $expiration = null)</em> - Stores the specified data in the handler&#8217;s persistent storage.</li>
</ul>
<p>Using these three functions, you can create simple cache blocks &#8211; pieces of code where you fetch data, check to see if it&#8217;s fresh, and then regenerate and store the data if it was stale or absent.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// Attempt to &quot;get&quot;</span>
<span class="nv">$data</span> <span class="o">=</span> <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">();</span>

<span class="c1">// Check to see if the data was a miss.</span>
<span class="k">if</span><span class="p">(</span><span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">isMiss</span><span class="p">())</span>
<span class="p">{</span>
    <span class="c1">// Run intensive code</span>
    <span class="nv">$data</span> <span class="o">=</span> <span class="nx">codeThatTakesALongTime</span><span class="p">();</span>

    <span class="c1">// Store data.</span>
    <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">store</span><span class="p">(</span><span class="nv">$data</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Continue as normal.</span>
<span class="k">return</span> <span class="nv">$data</span><span class="p">;</span>
</pre></div>
</div>
<p>The <em>store</em> function can take the expiration as an additional argument. This expiration can be a time, in seconds, that the cache should live or it can be a DateTime object that represents the time the cached item should expire. (This argument can be negative, which will result in an immediately stale cache.)</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// Using an age.</span>
<span class="nv">$data</span> <span class="o">=</span> <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">();</span>
<span class="k">if</span><span class="p">(</span><span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">isMiss</span><span class="p">())</span>
<span class="p">{</span>
    <span class="nv">$data</span> <span class="o">=</span> <span class="nx">expensiveFunction</span><span class="p">();</span>
    <span class="c1">// Cache expires in one hour.</span>
    <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">store</span><span class="p">(</span><span class="nv">$data</span><span class="p">,</span> <span class="mi">3600</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Using a DateTime.</span>
<span class="nv">$data</span> <span class="o">=</span> <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">();</span>
<span class="k">if</span><span class="p">(</span><span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">isMiss</span><span class="p">())</span>
<span class="p">{</span>
    <span class="nv">$data</span> <span class="o">=</span> <span class="nx">expensiveFunction</span><span class="p">();</span>

    <span class="c1">// Cache expires January 21, 2012.</span>
    <span class="nv">$expiration</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DateTime</span><span class="p">(</span><span class="s1">&#39;2012-01-21&#39;</span><span class="p">);</span>
    <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">store</span><span class="p">(</span><span class="nv">$data</span><span class="p">,</span> <span class="nv">$expiration</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The expiration sets the <em>maximum</em> time a cached object can remain fresh. In order to distribute cache misses, the Stash system tries to vary the expiration time for items by shortening a random amount; some handlers may also have size restrictions or other criteria for removing items early, and items can be cleared manually before they expire. Items will never be reported as fresh <em>after</em> the expiration time passes, however.</p>
</div>
<div class="section" id="stampede-protection">
<h2>Stampede Protection<a class="headerlink" href="#stampede-protection" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, when a cache item expires, multiple requests might come in for that item before it can be regenerated. If the process of generating it is very slow or expensive, these requests might stack up, each slowing down the system enough that previous requests can&#8217;t complete &#8211; this is a cache stampede. Stash has a stampede prevention function that&#8217;s fairly easy to use:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// Get the data from the cache using the &quot;STASH_SP_OLD&quot; technique for dealing with stampedes</span>
<span class="nv">$userInfo</span> <span class="o">=</span> <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="nx">Stash\Cache</span><span class="o">::</span><span class="na">STASH_SP_OLD</span><span class="p">);</span>

<span class="c1">// Check to see if the cache missed, which could mean that it either didn&#39;t exist or was stale.</span>
<span class="k">if</span><span class="p">(</span><span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">isMiss</span><span class="p">())</span>
<span class="p">{</span>
    <span class="c1">// Mark this instance as the one regenerating the cache. Because our protection method is</span>
    <span class="c1">// STASH_SP_OLD other Stash instances will use the old value and count it as a hit.</span>
    <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">lock</span><span class="p">();</span>

    <span class="c1">// Run the relatively expensive code.</span>
    <span class="nv">$userInfo</span> <span class="o">=</span> <span class="nx">loadUserInfoFromDatabase</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>

    <span class="c1">// Store the expensive code so the next time it doesn&#39;t miss. The store function marks the</span>
    <span class="c1">// stampede as over for now, so other Stash items will begin working as normal.</span>
    <span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">store</span><span class="p">(</span><span class="nv">$userInfo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="invalidation-methods">
<h2>Invalidation Methods<a class="headerlink" href="#invalidation-methods" title="Permalink to this headline">¶</a></h2>
<p>Stash&#8217;s stampede protection gives developers multiple ways to deal with stale data. Old values can be reused, new values set, or the cache can even be refreshed before it gets stale. Different methods can be set by passing the appropriate constant to Stash&#8217;s &#8220;get&#8221; function.</p>
<div class="section" id="stash-sp-none">
<h3>STASH_SP_NONE<a class="headerlink" href="#stash-sp-none" title="Permalink to this headline">¶</a></h3>
<p>By default Stash simply returns true for the &#8220;isMiss&#8221; function whenever the cache is invalid, meaning multiple cache misses can occur at once and stampede protection is not enabled. While not needed, this method can be explicitly set.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// preserves backward compatibility.</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">();</span>

<span class="c1">// recommended if this method is explicitly wanted as the default value may change in the future.</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="nx">STASH_SP_NONE</span><span class="p">);</span>

<span class="c1">// returns false if the item is missing or expired, no exceptions.</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">isMiss</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="stash-sp-precompute">
<h3>STASH_SP_PRECOMPUTE<a class="headerlink" href="#stash-sp-precompute" title="Permalink to this headline">¶</a></h3>
<p>The personal favorite method of the Stash developers, this method causes Stash to recalculate the cached item _before_ it misses.</p>
<p>When this method is used Stash-&gt;get takes one additional argument, the amount of time (in seconds) before the expiration when it should regenerate the cache.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// five minutes before the cache expires one instance will return a miss, causing the cache to regenerate.</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="nx">STASH_SP_PRECOMPUTE</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="stash-sp-old">
<h3>STASH_SP_OLD<a class="headerlink" href="#stash-sp-old" title="Permalink to this headline">¶</a></h3>
<p>When this method is enabled and a different instance has called the lock function, Stash will return the existing value in the cache even if it is stale.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="nx">STASH_SP_OLD</span><span class="p">);</span>

<span class="c1">// return false if another Stash instance is rebuilding the cached item even though the returned item is stale</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">isMiss</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="stash-sp-value">
<h3>STASH_SP_VALUE<a class="headerlink" href="#stash-sp-value" title="Permalink to this headline">¶</a></h3>
<p>When this method is enabled and a different instance has called the lock function Stash will return the supplied value.</p>
<p>This method takes one additional argument, the value to be returned while stampede protection is on.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="nx">STASH_SP_VALUE</span><span class="p">,</span> <span class="s1">&#39;Return this if stampede protection stops a miss&#39;</span><span class="p">);</span>

<span class="c1">// returns true only if the value is stale and no other processes have stated rebuilding the value.</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">isMiss</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="stash-sp-sleep">
<h3>STASH_SP_SLEEP<a class="headerlink" href="#stash-sp-sleep" title="Permalink to this headline">¶</a></h3>
<p>When this method is enabled and a different instance has called the lock function Stash will sleep and attempt to load the value upon waking up. This is not a website friendly method, but is potentially useful for cli or long running scripts.</p>
<p>When this method is used Stash-&gt;get takes two additional arguments, the time (in microseconds) to sleep before reattempting to load the cache and the amount of times to try and reload it before giving up. The maximum amount of time spent sleeping is the product of these two numbers.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// sleeps for .5 seconds, reattempts to load the cache,</span>
<span class="c1">// then sleeps again for another .5 seconds before making it&#39;s last attempt</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="nx">STASH_SP_SLEEP</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="clearing-data">
<h2>Clearing Data<a class="headerlink" href="#clearing-data" title="Permalink to this headline">¶</a></h2>
<p>Clearing data is just as simple as getting it. As with the <em>get</em> and <em>store</em> functions, the <em>clear</em> function takes a set key - if one isn&#8217;t set then the entire cache is cleared. Note that clearing a key will clear that key <em>and any keys beneath it in the hierarchy.</em></p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// Clearing a key.</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Cache</span><span class="p">(</span><span class="nv">$handler</span><span class="p">);</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">setupKey</span><span class="p">(</span><span class="s1">&#39;path/to/data/specific/123&#39;</span><span class="p">)</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">clear</span><span class="p">();</span>

<span class="c1">// Clearing a key with subkeys</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Cache</span><span class="p">(</span><span class="nv">$handler</span><span class="p">);</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">setupKey</span><span class="p">(</span><span class="s1">&#39;path/to/data/general&#39;</span><span class="p">)</span> <span class="c1">// clears &#39;path/to/data/*&#39;</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">clear</span><span class="p">();</span>

<span class="c1">// Clearing everything.</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash</span><span class="p">(</span><span class="nv">$handler</span><span class="p">);</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">clear</span><span class="p">();</span>
</pre></div>
</div>
<p>The Pool class can also clear the entire cache:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$pool</span><span class="o">-&gt;</span><span class="na">flush</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="purging-data">
<h2>Purging Data<a class="headerlink" href="#purging-data" title="Permalink to this headline">¶</a></h2>
<p>The <em>purge</em> function removes stale data from the cache backends while leaving current data intact. Depending on the size of the cache and the specific handlers in use this can take some time, so it is best called as part of a separate maintenance task or as part of a cron job.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$stashFileSystem</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Handler\FileSystem</span><span class="p">();</span>

<span class="c1">// Purge the FileSystem</span>
<span class="nv">$stash</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stash\Cache</span><span class="p">(</span><span class="nv">$stashFileSystem</span><span class="p">);</span>
<span class="nv">$stash</span><span class="o">-&gt;</span><span class="na">purge</span><span class="p">();</span>
</pre></div>
</div>
<p>The Pool class can also purge the cache:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$pool</span><span class="o">-&gt;</span><span class="na">purge</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="Contents.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Stash</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics.html">Basic Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Invalidation.html">Invalidation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Handlers.html">Handlers</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/Usage.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="Contents.html">Stash 0.9.5 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Robert Hafner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>